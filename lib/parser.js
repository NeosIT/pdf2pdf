/**
 * Created with JetBrains WebStorm.
 * User: thomas
 * Date: 08.05.13
 * Time: 07:31
 * To change this template use File | Settings | File Templates.

 generatePDF creates a searchable PDF by placing an image of the original document over the text generated by tesseract-ocr
 options:
 input_tiff: tiff file to use
 input_html: tesseract-ocr output
 temp_path:  temporary directory to use
 output_pdf: filename of the PDF to create
 callback:   callback to execute afterwards
 */

var fs = require('fs');
var cheerio = require('cheerio');
var pdfkit = require('pdfkit');
var gm = require('gm');
var crypto = require('crypto');

function generatePDF(input_tiff, input_html, temp_path, output_pdf, cb_status, callback) {

    fs.readFile(input_html, function (err, data) { //read tesseract-ocr output
        if (err) {
            console.error(err)
        }
        else {
            parse_html(cheerio.load(data), input_tiff, output_pdf, [temp_path, '/ocr-', crypto.randomBytes(6).readUInt32LE(0)].join(''), cb_status, callback); //run the parser
            fs.unlink(input_html); //remove temporary file
        }

    })
}

function parse_html(html_data, in_tiff, out_pdf, tmp, cb_status, callback) {

    var idx_page = 0;
    var replacements = new Object()

    //replacement table for ligatures
    replacements['ﬀ'] = 'ff'
    replacements['ﬁ'] = 'fi'
    replacements['ﬂ'] = 'fl'
    replacements['ﬃ'] = 'ffi'
    replacements['ﬄ'] = 'ffl'
    replacements['ﬅ'] = 'ft'
    replacements['ﬆ'] = 'st'
    replacements['—'] = '-'

    gm(in_tiff).size(function (err, size) { //get the image dimensions

        doc = new pdfkit({size: [size.width, size.height]}); //create PDF with determined size
        var max_pages = html_data('.ocr_page').length; //get number of pages of the document


        function wrapper(idx_page) { //process given page
            if (cb_status)
                cb_status('writing PDF '+Math.round((idx_page/max_pages)*100)+'% done');

            if (idx_page == max_pages) { //write the file after the last page has been processed
                doc.write(out_pdf)
                if (typeof callback == 'function')
                    callback(null)

                return 0;
            }

            gm([in_tiff, '[', idx_page, ']'].join('')).write([tmp, idx_page + '.jpg'].join(''), function (err) { //convert current page of multi page tiff to jpg

                if (err) {
                    console.error(err)
                }

                if (idx_page > 0) { //add new page after the last one has been processed
                    doc.addPage()
                }

                var item_page = html_data('.ocr_page')[idx_page] //get current page
                var max_words = html_data(item_page).find('.ocrx_word').length //get number of words on current page


                html_data(item_page).find('.ocrx_word').each(function (idx_word, item_word) { //parse current page and process each word individually
                    var str = html_data(item_word).text() //get string from object
                    var x1 = parseInt(item_word.attribs.title.split(';')[0].split(' ')[1], 10) //get bounding box coordinates
                    var x2 = parseInt(item_word.attribs.title.split(';')[0].split(' ')[3], 10)
                    var y1 = parseInt(item_word.attribs.title.split(';')[0].split(' ')[2], 10)
                    var y2 = parseInt(item_word.attribs.title.split(';')[0].split(' ')[4], 10)

                    if (str) { //check for empty string
                        for (var i in replacements)
                            str = str.replace(i, replacements[i]) //replace ligatures

                        doc.fontSize(y2 - y1) //roughly calculate font size from height of bounding box

                        var fontScaleFactor = 1

                        while (((x2 - x1)) < doc.widthOfString(str)) { //scale down font size until string fits into bounding box
                            fontScaleFactor *= .9
                            doc.fontSize((y2 - y1) * fontScaleFactor)
                        }

                        if (str.trim().length >= 1) { //remove whitespaces and check for empty string
                            var options = {width: (x2 - x1), align: 'center'} //center string in bounding box
                            if (str.trim().length == 1)
                                options = {} //only center string in bounding box if string length > 1; workaround for PDFkit bug
                            doc.text(str, x1, y1, options) //write string to PDF
                        }
                    }

                    if (idx_word == max_words - 1) { //check for last word
                        doc.image([tmp, idx_page + '.jpg'].join(''), 0, 0) //place image over text
                        fs.unlink([tmp, idx_page + '.jpg'].join('')) //remove temporary file
                    }
                })
                wrapper(++idx_page)//recursively parse through document until
            })
        }

        wrapper(0) //start parsing
    })

}

exports.generatePDF = generatePDF