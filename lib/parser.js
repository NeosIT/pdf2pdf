/**
 * Created with JetBrains WebStorm.
 * User: thomas
 * Date: 08.05.13
 * Time: 07:31
 * To change this template use File | Settings | File Templates.

 generatePDF creates a searchable PDF by placing an image of the original document over the text generated by tesseract-ocr
 options:
 input_tiff: tiff file to use
 input_html: tesseract-ocr output
 temp_path:  temporary directory to use
 output_pdf: filename of the PDF to create
 callback:   callback to execute afterwards
 */

var fs = require('fs');
var cheerio = require('cheerio');
var gm = require('gm');
var pdfkit = require('pdfkit');

var replacements = { //replacement table for ligatures
    "ﬀ": "ff",
    "ﬁ" : 'fi',
    "ﬂ" : 'fl',
    "ﬃ" : 'ffi',
    "ﬄ" : 'ffl',
    "ﬅ" : 'ft',
    "ﬆ" : 'st',
    "—" : '-'
}


function writePDF(input_img, input_html, temp_path, output_pdf, i, doc, cb_status, callback){
    if (i == input_img.length){
        doc.write(output_pdf)
        callback(null)
    }
    else{
        gm(input_img[i]).size(function (err, size) { //get the image dimensions
            if (i != 0){
                doc.addPage({size: [size.width, size.height]})
            }
            fs.readFile(input_html[i], function (err, data) { //read tesseract-ocr output
                if (err)
                    callback(err)
                else {
                    var html_data = cheerio.load(data)

                    gm(input_img[i]).write(input_img[i] + '.jpg', function (err) { //convert current page of multi page tiff to jpg

                        if (err)
                            callback(err)

                        var max_words = html_data('.ocrx_word').length //get number of words on current page
                        if (cb_status('writing page ' + (i+1) + ' of ' +input_img.length) == false){
                            callback(new Error('Process cancelled'))
                            return -1
                        }
                        html_data('.ocrx_word').each(function (idx_word, item_word) { //parse current page and process each word individually

                            var str = html_data(item_word).text() //get string from object
                            var x1 = parseInt(item_word.attribs.title.split(';')[0].split(' ')[1], 10) //get bounding box coordinates
                            var x2 = parseInt(item_word.attribs.title.split(';')[0].split(' ')[3], 10)
                            var y1 = parseInt(item_word.attribs.title.split(';')[0].split(' ')[2], 10)
                            var y2 = parseInt(item_word.attribs.title.split(';')[0].split(' ')[4], 10)

                            if (str) { //check for empty string
                                for (var j in replacements)
                                    str = str.replace(j, replacements[j]) //replace ligatures

                                doc.fontSize(y2 - y1) //roughly calculate font size from height of bounding box

                                var fontScaleFactor = 1

                                while (((x2 - x1)) < doc.widthOfString(str)) { //scale down font size until string fits into bounding box
                                    fontScaleFactor *= .9
                                    doc.fontSize((y2 - y1) * fontScaleFactor)
                                }

                                if (str.trim().length >= 1) { //remove whitespaces and check for empty string
                                    var options = {width: (x2 - x1), align: 'center'} //center string in bounding box
                                    if (str.trim().length == 1)
                                        options = {} //only center string in bounding box if string length > 1; workaround for PDFkit bug
                                    doc.text(str, x1, y1, options) //write string to PDF
                                }
                            }

                            if (idx_word == max_words - 1) { //check for last word
                                doc.image(input_img[i] + '.jpg', 0, 0) //place image over text
                                writePDF(input_img, input_html, temp_path, output_pdf, ++i, doc, cb_status, callback)
                            }
                        })
                    })
                }
            })
        })
    }
}


function generatePDF(input_img, input_html, temp_path, output_pdf, cb_status, callback) {
    gm(input_img[0]).size(function (err, size) { //get the image dimensions
        var doc = new pdfkit({size: [size.width, size.height]}) //create PDF with determined size
        writePDF(input_img, input_html, temp_path, output_pdf, 0, doc, cb_status, function (err){
            callback (err)
        })
    })
}

exports.generatePDF = generatePDF